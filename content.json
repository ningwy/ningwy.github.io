[{"title":"Activity详解（一）——Activity的生命周期全分析","date":"2017-01-04T05:58:29.000Z","path":"2017/01/04/Activity详解（一）——Activity的生命周期全分析/","text":"Android的生命周期相信大家都很熟悉了，这里记录的是自己在学习开发过程中的一些经验之谈，希望以后自己忘记了能有个笔记翻一下。 1.Activity正常的生命周期&ensp;&ensp;&ensp;&ensp; 我们平常所说的生命周期就是正常的生命周期，也是Activity典型的生命周期，从Activity创建到结束会调用如下方法： &ensp;&ensp;&ensp;&ensp; （1）onCreate：在Activity创建的时候调用。我们新建一个Activity的时候就会看到这个方法，通常在里面初始化资源。 &ensp;&ensp;&ensp;&ensp; （2）onStart：onCreate方法调用完成之后就会调用onStart方法。此时Activity已经属于可见状态，只不过我们还看不到，因为此时Activity还处于后台。要看到Activity得等onResume方法执行完毕。 &ensp;&ensp;&ensp;&ensp; （3）onResume：该方法表示Activity已经被调到前台来了，不仅属于可见状态，我们肉眼还可以看到。要注意该方法和onStart方法的对比，onStart方法虽然也表示Activity处于可见状态，当时此时Activity还看不到，而onResume方法调用之后，Activity才算真正的可见。 &ensp;&ensp;&ensp;&ensp; （4）onPause：在用户点击返回键或者后台键时，Activity会调用该方法，表示Activity被挂起了，看不到了。 &ensp;&ensp;&ensp;&ensp; （5）onStop：在onPause方法执行完之后就会紧接着执行该方法，理论上是有可能在执行完onPause方法之后回到Activity而不执行onStop方法，不过这要求用户拥有极快的手速，所以一般不考虑这种情况，即调用完onPause之后马上调用onStop方法，而不考虑着两个方法之间还会有什么逻辑。onStop距离Activity真正被销毁只有一步之遥了，所以可以在这个方法里面做一些轻量级资源的回收保存的操作，但不能太耗时。 &ensp;&ensp;&ensp;&ensp; （6）onDestroy：调用完该方法之后Activity算是真正地被销毁了，所以需要在这个方法里面做一些资源释放操作，例如释放数据库连接等。 &ensp;&ensp;&ensp;&ensp; （7）onRestart：该方法是在调用onStop方法时，如果用户返回Activity，那么就会回调该方法，然后调用onStart，进入Activity的生命周期，而不会调用onCreate。","tags":[{"name":"Android","slug":"Android","permalink":"ningwy.github.io/tags/Android/"}]},{"title":"getRunningTasks() deprecated之后如何获得topActivity","date":"2016-05-26T05:58:29.000Z","path":"2016/05/26/getRunningTasks() deprecated之后如何获得topActivity/","text":"前言在Android sdk 22之前，要想获得topActivity，只需要用getRunningTasks(int maxNum)即可返回当前正在运行的任务栈，从任务栈中取出第一个即可，如下：123ActivityManager am = ((ActivityManager) getSystemService(ACTIVITY_SERVICE));List&lt;ActivityManager.RunningTaskInfo&gt; taskInfo = am.getRunningTasks(5);String packageName = taskInfo.get(0).topActivity.getPackageName(); 如上即可获得topActivity的包名，有了包名之后想干什么就干什么了。不过，如果就这么简单，就不值得记录学习了。 getRunningTasks() was deprecated在Android L(也就是sdk 22)之后，getRunningTasks()方法以及被抛弃，原因是出于保护用户隐私之类的。如下： for L we do plan to have a new solution that will address some of the existing use cases of getRecentTasks(): we hope to expose the system’s internal usage stats service in a new and expanded form that is available to third party apps through the SDK.The new usage stats service should have two major pieces of information. First, it will provided aggregated stats of the time the user spent in each app, and the last launch time of those apps, rolled up over days, weeks, months, and years. Second, it will include detailed usage events over the last few days, describing the time and ComponentName when any activity transitions to the foreground or background.Access to this new usage data will require that the user explicitly grant the app access to usage stats through a new settings UI. They will be able to see all apps that have access and revoke access at any point. 大概意思就是该方法以及被抛弃，然后用了一种新的更好地方式来代替，不过这种方式需要用户授予权限。这种方式就是用UsageStatsManager，详细请点击here。下面直接上代码，在Android L之后获取topActivity包名：1234567891011121314/** * 获得top activity的包名 * @return */public String getTopPackage()&#123; long ts = System.currentTimeMillis(); UsageStatsManager mUsageStatsManager = (UsageStatsManager)getSystemService(Context.USAGE_STATS_SERVICE); List&lt;UsageStats&gt; usageStats = mUsageStatsManager.queryUsageStats(UsageStatsManager.INTERVAL_BEST, ts-1000, ts); if (usageStats == null || usageStats.size() == 0) &#123;//如果为空则返回\"\" return \"\"; &#125; Collections.sort(usageStats, mRecentComp);//mRecentComp = new RecentUseComparator() return usageStats.get(0).getPackageName();&#125; 下面是RecentUseComparator的代码123456static class RecentUseComparator implements Comparator&lt;UsageStats&gt; &#123; @Override public int compare(UsageStats lhs, UsageStats rhs) &#123; return (lhs.getLastTimeUsed() &gt; rhs.getLastTimeUsed()) ? -1 : (lhs.getLastTimeUsed() == rhs.getLastTimeUsed()) ? 0 : 1; &#125;&#125; 使用UsageStatsManager需要如下权限：123&lt;uses-permission xmlns:tools=\"http://schemas.android.com/tools\" android:name=\"android.permission.PACKAGE_USAGE_STATS\" tools:ignore=\"ProtectedPermissions\" /&gt; 此外还需要用户授权去请求数据，可以用一下代码引导用户去设置页面开启12Intent intent = new Intent(Settings.ACTION_USAGE_ACCESS_SETTINGS);startActivity(intent); 当前还可以通过一下代码来检测用户是否已经授权，如果已经授权过了，则不用重复去引导用户12345678910111213141516/** * 使用UsageStatsManager需要用户允许开启，该方法用于判断用户是否已经授权 * @param context * @return true:还没有授权 false:已经授权 */public static boolean needPermissionForBlocking(Context context) &#123; try &#123; PackageManager packageManager = context.getPackageManager(); ApplicationInfo applicationInfo = packageManager.getApplicationInfo(context.getPackageName(), 0); AppOpsManager appOpsManager = (AppOpsManager) context.getSystemService(Context.APP_OPS_SERVICE); int mode = appOpsManager.checkOpNoThrow(AppOpsManager.OPSTR_GET_USAGE_STATS, applicationInfo.uid, applicationInfo.packageName); return (mode != AppOpsManager.MODE_ALLOWED); &#125; catch (PackageManager.NameNotFoundException e) &#123; return true; &#125;&#125; 如此，我们就可以在全平台中获得topActivity的包名了，也就可以“为所欲为”啦。 demo下面是我做的一个应用锁小应用，目前在Android 4.3和Android 5.1完美运行。话不多说，show you the code !在service中开启服务来监听应用程序的启动 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110public class AppLockService extends Service &#123; /** * 用来让当WatchDogService被stop时停止循环遍历任务栈的topActivity * true:循环遍历 * false:停止遍历 */ private boolean flag = false; /** * 任务栈topActivity的包名 */ private String packageName = \"\"; public AppLockService() &#123; &#125; @Override public IBinder onBind(Intent intent) &#123; // TODO: Return the communication channel to the service. throw new UnsupportedOperationException(\"Not yet implemented\"); &#125; @Override public void onCreate() &#123; //分线程中循环遍历 new Thread() &#123; @Override public void run() &#123; flag = true; while (flag) &#123; //获取包名 if (Build.VERSION.SDK_INT &lt; Build.VERSION_CODES.LOLLIPOP) &#123;//版本小于lollipop的 ActivityManager am = ((ActivityManager) getSystemService(ACTIVITY_SERVICE)); List&lt;ActivityManager.RunningTaskInfo&gt; taskInfo = am.getRunningTasks(5); packageName = taskInfo.get(0).topActivity.getPackageName(); &#125; else &#123; //版本为Lollipop及以上 if (needPermissionForBlocking(getApplicationContext())) &#123; //如果用户没有授权，引导用户去设置页面授权 Intent intent = new Intent(Settings.ACTION_USAGE_ACCESS_SETTINGS); //在service中开启activity需要为intent添加FLAG_ACTIVITY_NEW_TASK的flag intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK); startActivity(intent); &#125; else &#123; //得到包名 packageName = getTopPackage(); &#125; Log.e(\"TAG\", \"top app = \" + packageName); //有了包名之后就可以与应用锁数据库里面的包名做匹配 //如果匹配上就弹出输入密码的页面，酱紫就可以实现应用锁了(是不是有点想得太简单了= =) &#125; SystemClock.sleep(50); &#125; &#125; &#125;.start(); &#125; /** * 获得top activity的包名 * * @return */ @TargetApi(21) public String getTopPackage() &#123; long ts = System.currentTimeMillis(); UsageStatsManager mUsageStatsManager = (UsageStatsManager) getSystemService(Context.USAGE_STATS_SERVICE); List&lt;UsageStats&gt; usageStats = mUsageStatsManager.queryUsageStats(UsageStatsManager.INTERVAL_BEST, ts - 1000, ts); if (usageStats == null || usageStats.size() == 0) &#123;//如果为空则返回\"\" return \"\"; &#125; Collections.sort(usageStats, new RecentUseComparator()); return usageStats.get(0).getPackageName(); &#125; /** * */ @TargetApi(21) static class RecentUseComparator implements Comparator&lt;UsageStats&gt; &#123; @Override public int compare(UsageStats lhs, UsageStats rhs) &#123; return (lhs.getLastTimeUsed() &gt; rhs.getLastTimeUsed()) ? -1 : (lhs.getLastTimeUsed() == rhs.getLastTimeUsed()) ? 0 : 1; &#125; &#125; /** * 使用UsageStatsManager需要用户允许开启，该方法用于判断用户是否已经授权 * * @param context * @return true:还没有授权 false:已经授权 */ @TargetApi(19) public static boolean needPermissionForBlocking(Context context) &#123; try &#123; PackageManager packageManager = context.getPackageManager(); ApplicationInfo applicationInfo = packageManager.getApplicationInfo(context.getPackageName(), 0); AppOpsManager appOpsManager = (AppOpsManager) context.getSystemService(Context.APP_OPS_SERVICE); int mode = appOpsManager.checkOpNoThrow(AppOpsManager.OPSTR_GET_USAGE_STATS, applicationInfo.uid, applicationInfo.packageName); return (mode != AppOpsManager.MODE_ALLOWED); &#125; catch (PackageManager.NameNotFoundException e) &#123; return true; &#125; &#125; @Override public void onDestroy() &#123; flag = false; &#125;&#125; 结语至此，在getRunningTasks方法被抛弃后，终于完成了一个能够适应于多版本sdk的应用锁。不过，也只是仅仅能用而已，以上肯定不是最优的解决方案。由于自己功力尚浅，如果有错误，看到的小伙伴请多多指教！","tags":[{"name":"Android","slug":"Android","permalink":"ningwy.github.io/tags/Android/"}]},{"title":"用命令 hexo d 部署到github上防止README.md被污染","date":"2016-03-19T11:27:04.000Z","path":"2016/03/19/用命令-hexo-d-部署到github上防止README-md被污染/","text":"问题描述如果在github上新建一个github pages时忘了添加README.md文件，这时直接在github上面新建一个README.md文件是不行的，因为每次用命令hexo d将本地提交到github时，README.md文件都会消失。 解决方法1.在hexo博客根站点下的source文件夹建立README.md文件。2.在站点配置文件_config.yml中找到skip_render参数，在其值上添加 README.md，如下：1skip_render: README.md 保存退出，重新部署即可。","tags":[{"name":"Hexo","slug":"Hexo","permalink":"ningwy.github.io/tags/Hexo/"}]}]